#
# Script to calculate cultivation area maize change til 2100
#

#Packages 
require(terra)      # Handling rasterdata
require(PCICt)      # 365 d clender
require(lubridate)  # Handling dates 
library(tidyverse)  

# Preprocessing and calculation of rainy season (reduce data to growing Season)
prep_cordex      <- function (file_list, studyarea, maize, unit, start_data, end_data) {


  # Create raster stack from all files in file_list
  rasterstack <- rast(file_list)
  
  # define stack crs and crop to the extent of studyare 
  crs(rasterstack) <- crs(studyarea)
  rasterstack_crop <- crop(rasterstack, ext(studyarea))
  
  # Mask climate data to maize cultivation areas from monfreda et. al 
  # Resample maize cultivationdata to rasterstack res 
  maize_resampled <- terra::resample(maize, rasterstack_crop)
  rasterstack_mask <- terra::mask(rasterstack_crop, maize_resampled)
  
  if(unit == "mm/d"){
    rasterstack_mask_unit <- rasterstack_mask * 86400
  }else if(unit == "째C"){
    rasterstack_mask_unit <- rasterstack_mask - 273.15
  }
  
  # Renaming Data 
  names(rasterstack_mask_unit) <- seq(as.PCICt(start_data, cal = "365_day"), as.PCICt(end_data, cal = "365_day"), by = "day")
  
  return(rasterstack_mask_unit)
}
subset_data_year <- function(year, data){
  
  # Create a yearly subset of any data indexed  by a Date
  
  #define start of the year
  #y_start <- unique(year(ymd(c(names(data)))))
  start <- as.Date(paste0(year,"-01-01"), format = "%Y-%m-%d")

  #define lasst day of year
  #y_end <- unique(year(ymd(c(names(data)))))[i]
  end <- as.Date(paste0(year,"-12-31"), format = "%Y-%m-%d")

  #subset one year by start and end of year
  #Sub creates a T (True == in time range) or F (not in time range) binary mask
  #The mask is uses to subset the actual Data
  
  if(class(data) == "SpatRaster"){
    
    sub <- names(data) >= as.POSIXct(start) & names(data) <= as.POSIXct(end)
    subset <- data[[sub]]
  
    return(subset)
    
  } else if(class(data) == "data.frame" ){
    print("I am class df")
    #sub <- colnames(data) >= as.POSIXct(start) & names(data) <= as.POSIXct(end)
    subset <- data[,colnames(data) >= as.POSIXct(start) & names(data) <= as.POSIXct(end)]
    
    return(subset)
  }
}
calc_rainyseason <- function(prec){
  
  ## creating empty raster to store output of the following loops in it
  prec_q_quer <- rast(extent = ext(prec), resolution = res(prec), crs = crs(prec))  # Q_quer = Mean precipitation of one year for each pixel
  precipitation_anomaly <- rast(extent = ext(prec), resolution = res(prec), crs = crs(prec))  # daily precipitation anomaly data for one year
  storage_cumulative <- rast(extent = ext(prec), resolution = res(prec), crs = crs(prec))  # cumulative sum of the precipitation anomaly for each year
  table_start_end_day <- as.data.frame(prec, xy = TRUE)[, 1:2]  
  
  l <- seq(1, nlyr(prec), 365)
  m <- seq(365, nlyr(prec), 365)
  
  # sequence that indicates the layer that represents the first/last day of the static rainy season of each year (required to subset dataset)
  # "60" represents the day of the year we are postulating to be the earliest the growing season could start 
  # "212" represents the day of the year we are postulating to be the latest the growing season could start
  l2 <- seq(60, nlyr(prec), 365) 
  m2 <- seq(212, nlyr(prec), 365) 
  
  # vector of numbers to name each year of time period
  n <- c(substr(names(prec[[1]]), 1, 4):substr(names(prec[[nlyr(prec)]]), 1, 4))  
  
  
  ### loop to calculate Q_quer
  # just in case: sets all run variables to zero 
  i <- y_start <- j_start <- y_end <- j_end <- 0
  
  ## the loop to calculate Q_quer
  for (i in 1:length(unique(year(ymd(c(names(prec))))))){
    
    # Create a yearly subset from the input data to calc the mean precipitation for eatch pixel
    subset <- subset_data_year(as.character(n[i]), prec)
    
    #calc Q_quer = Mean precipitation of one year for each pixel
    result <- app(subset, fun = mean) # app() applies cell based calculations
    add(prec_q_quer) <- result
    names(prec_q_quer)[i] <- unique(year(ymd(c(names(prec)))))[i]
  }
  
  ### loop to calculate daily precipitation anomaly for each day and pixel of the year
  # just in case: sets all run variables to zero 
  i <- y_start <- j_start <- y_end <- j_end <- 0
  
  ## the loop precipitation anomaly
  for (i in 1:nlyr(prec_q_quer)) {
    
    subset <- subset_data_year(as.character(n[i]), prec)
    
    #calcs the anomaly -> the true precepetation value minus the mean precipitation value (Q_quer) for each pixel
    result <- subset - prec_q_quer[[i]] 
    add(precipitation_anomaly) <- result
  }
  
  ### the loop that calculates the cumulative anomaly for each day of a year
  # just in case: sets all run variables to zero 
  j <- i <- 0
  
  ## the loop cumulative anomaly
  for (i in 1:(nlyr(precipitation_anomaly)/365)) {
    cumulativ <- 0
    sub_anomaly <- 0
    # s <- 1  
    # e <- 365  
    # 
    # l <- seq(s, nlyr(precipitation_anomaly), 365)
    # m <- seq(e, nlyr(precipitation_anomaly), 365)
    # 
    # sub_anomaly <- c(precipitation_anomaly[[l[i]:m[i]]])
    sub_anomaly <- subset_data_year(n[i], precipitation_anomaly)
    
    cumulativ <- app(sub_anomaly, fun = cumsum)
    
    add(storage_cumulative) <- cumulativ
  }
  
  ### Loop to identify the layer (=day) of each year where the pixel value is the the minimum (=start of the rainy season)
  # just in case: sets all run variables to zero 
  i <- t <- 0
  
  ## the loop to find 
  for (i in 1:(nlyr(storage_cumulative)/365)) {
    
    table_cumulative <- as.data.frame(subset_data_year(n[i], storage_cumulative)) # subsetting the data year wise and converting it into a dataframe
    min_index <- apply(table_cumulative, 1, which.min) # identifies for each pixel the column (=day of selected year) where the value is the minimum
    
    t <- cbind(start_day_ = (min_index + 59), # creating a new dataframe with the start day of the rainy season for the selected day (we need to add 59 days since we cutted out the first 60 days of the year) 
               end_day_ = (min_index+120+59)) # the end day is defined as the day the growing period of maize (120 days after seeding) is reached
    colnames(t)[1] <- paste0("start_day_", n[i]) # renaming the columns (adding the selected year)
    colnames(t)[2] <- paste0("end_day_", n[i])  # renaming the columns (adding the selected year)
    table_start_end_day <- cbind(table_start_end_day, t) # adding the dataframe we just created to the dataframe containing x-/y-coordinates
  }
  
  results_rs <- list(prec_q_quer = prec_q_quer, precipitation_anomaly = precipitation_anomaly,
                     storage_cumulative = storage_cumulative, table_start_end_day = table_start_end_day)
  
  return(results_rs)
}

# Calculate climatic indices 
temperatur_thresh <- function(T_max, T_mean, table_start_end_day){
  
  # Classification rules 
  # 0: criteria have not been met
  # 1: Optima (15 - 32째C) 
  # 2: Heat day affecting yield (T mean over 32째C) 
  # 3: Lethal (T max over 46째C)
  
  
  # Calc a Vector containing all unique Years in one input stack (naming data by data function prep)
  n <- c(substr(names(prec[[1]]), 1, 4):substr(names(prec[[nlyr(prec)]]), 1, 4))  
  
  # Stack to df 
  table_Tmean <- as.data.frame(T_max)
  table_Tmax  <- as.data.frame(T_mean)
  
  # Create empty data.frames to store results 
  heat_days_growing_season <- as.data.frame(T_mean, xy = TRUE)[, 1:2]   # creating dataframe with x and y column 
  heat_days_possible <- as.data.frame(T_mean, xy = TRUE)[, 1:2]   # creating dataframe with x and y column 
  heat_days_class_raster <- rast(extent = ext(T_mean), resolution = res(T_mean), crs = crs(T_mean)) #emty raster to store loop output data
  n <- c(substr(names(T_mean[[1]]), 1, 4):substr(names(T_mean[[nlyr(T_mean)]]), 1, 4))# vector with years. used to name new data
  
  # ts = time_start vector containing index values pointing to the start of season of a specific year 
  # te = time_end   vector containing index values pointing to the start of season of a specific year 
  ts <- seq(3,ncol(table_start_end_day), 2) # vector we need to specify the column for the start day of rainy season for each year
  te <- seq(4,ncol(table_start_end_day), 2) # vector we need to specify the column for the end day of growing season for each year
  
  
  # Initialize all variabels used inside the lopp with zero 
  j <- i <- s <- e <- l <- m <- u <- b <- t <- 0
  
  for (j in 1:(ncol(table_Tmean)/365)) {
    sub_Tmean <- data.frame()
    sub_Tmax <- data.frame()
    # s <- 1  
    # e <- 365  
    # l <- seq(s, ncol(table_Tmean), 365)
    # m <- seq(e, ncol(table_Tmean), 365)
    
    # sub_mean <- table_Tmean[l[j]:m[j]]           
    # sub_max <- table_Tmax[l[j]:m[j]]
    
    sub_mean <- subset_data_year(n[i], table_Tmean)            # subsetting the mean Temperature dataframe to the right year
    sub_max <-  subset_data_year(n[i], table_Tmax)             # subsetting the max Temperature dataframe to the right year
    for (i in 1:nrow(sub_mean)) {
      u <- sub_mean[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]]   # this loop subsets the selected year data to the dynamic growing season for each pixel
      b <- sub_max[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]]    # this loop subsets the selected year data to the dynamic growing season for each pixel
      colnames(u) <- c(1:120)
      colnames(b) <- c(1:120)
      sub_Tmean <- rbind(sub_Tmean, u)
      sub_Tmax <- rbind(sub_Tmax, b)
    }
    
    
    t <- ifelse(sub_Tmax >= 46, 3,    #### CHECK THIS PART
                ifelse(sub_Tmean > 32, 2, #### CHECK THIS PART
                       ifelse(sub_Tmean >= 15 & sub_Tmean <= 32, 1, 0)))#### CHECK THIS PART
    #heat_days_possible <- cbind(heat_days_possible, t)#### CHECK THIS PART
    
    # name all days in the growing season 
    colnames(t) <- paste0("day_", c(1:121))
    
    # combine coordinates from rasterstack and classified values to one df
    ge <- cbind(as.data.frame(T_mean, xy = TRUE)[, 1:2], t)
    
    # Create raster from df
    ge_r <- rast(ge, type = "xyz", crs = "EPSG:4326")
    
    # get maximum Value from each pixel 
    p_2 <- app(ge_r, fun = max)  
    
    names(p_2) <- n[j]
    add(heat_days_class_raster) <- p_2
  }
  
  list_results <- list()
  
  return(heat_days_class_raster)
}
prec_sums         <- function(prec, table_start_end_day){
  
  # Classification rules
  # 0: criteria have not been met
  # 1: min (400 - 600mm) 
  # 2: Optima (600 - 1200mm) 
  # 3: max (1200 - 1800mm)
  
  # Create storage Variabels 
  prec_possible <- as.data.frame(prec, xy = TRUE)[, 1:2]          # creating dataframe with x and y column
  n <- c(substr(names(T_mean[[1]]), 1, 4):substr(names(T_mean[[nlyr(T_mean)]]), 1, 4))                          # vector with years. used to name new data
  ts <- seq(3,ncol(table_start_end_day), 2) # vector we need to specify the column for the start day of rainy season for each year
  te <- seq(4,ncol(table_start_end_day), 2) # vector we need to specify the column for the end day of growing season for each year
  
  # from rasterstack to df 
  table_prec <- as.data.frame(prec)
  
  # Initialize all Variables used in the loop with 0 
  j <- i <- s <- e <- l <- m <- t <- u <- 0
  
  for (j in 1:(ncol(table_prec)/365)) {
    
    sub_rs <- data.frame()

    sub <- subset_data_year(n[i], table_prec)
    
    for (i in 1:nrow(sub)) {
      u <- sub[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]]
      colnames(u) <- c(1:121)
      sub_rs <- rbind(sub_rs, u)
    }
    
    sum_rs <- as.data.frame(apply(sub_rs, 1, FUN = sum))
    colnames(sum_rs)[1] <- paste0("mm_", n[j])
    
    
    t <- ifelse(sum_rs >= 400 & sum_rs <= 600, 2, 
                ifelse(sum_rs > 600 & sum_rs <= 1200, 1, 
                       ifelse(sum_rs > 1200 & sum_rs <= 1800, 3, 0)))
    
    prec_possible <- cbind(prec_possible, t)
    
  }
  
  prec_possible_raster <- rast(prec_possible, type = "xyz", crs = "EPSG:4326")
  
  return(prec_possible_raster)
  
}
drougth_spells    <- function(prec, table_start_end_day){
  
  # Classification rules 
  # 1: Optimum: DS <5 d
  # 2: Ernteminderung: DS 5-13 d 
  # 3: Lethal: DS >13 d
  
  # Storage
  drought_spells <- as.data.frame(prec, xy = T)[, 1:2]           # creating dataframe with x and y column
  n <- c(substr(names(T_mean[[1]]), 1, 4):substr(names(T_mean[[nlyr(T_mean)]]), 1, 4))                         # vector with years. used to name new data
  ts <- seq(3,ncol(table_start_end_day), 2) # vector we need to specify the column for the start day of rainy season for each year
  te <- seq(4,ncol(table_start_end_day), 2) # vector we need to specify the column for the end day of growing season for each year
  
  
  # Rasterstack to df 
  table_prec <- as.data.frame(prec)
  
  j <- i <- s <- e <- l <- m <- t <- u <- 0
  
  for (j in 1:(ncol(table_prec)/365)) {
    
    sub_rs <- data.frame()
    
    sub <- subset_data_year(n[i], table_prec)
    
    for (i in 1:nrow(sub)) {
      
      # subset (year) the subset to only rainy season per year 
      u <- sub[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]]
      colnames(u) <- c(1:121)
      sub_rs <- rbind(sub_rs, u)
    }
    
    table_sub_rs <- as.data.frame(sub_rs)
    
    # If a day during the rainy season has less than 0.85 it is classified as a drought spell 
    t <- ifelse(table_sub_rs < 0.85, 1, 0)
    
    fe <- apply(t, 1, FUN = function(x=t) {
      
      # Compute the lengths and values of runs of equal values in a vector (rle())
      rle <- rle(x)
      
      max_p <- max(rle$lengths[rle$values!=0])
      op <- ifelse(max_p > 13, 3,
                   ifelse(max_p < 13 & max_p > 5, 2, 1))
    })
    
    drought_spells <- cbind(drought_spells, fe)
    # names(drought_spells)[i+2] <- n[i]      ### check this part 
  }
  
  names(drought_spells)[3:ncol(drought_spells)] <- n
  
  
  ## convert result dataframe into raster stack
  drought_spells_rast <- rast(drought_spells, type = "xyz", crs = "EPSG:4326")
  
  return(drought_spells_rast)
}

# Combine the climate indices and classify to (un)favourabel Maize cultivation areas 
combined_classification <- function(prec_possible_raster, heat_days_class_raster, drought_spells_rast){
  
  
  # Storage
  TP_Final <- rast(extent = ext(prec_possible_raster), resolution = res(prec_possible_raster), crs = crs(prec_possible_raster))
  TPD_Final <- rast(extent = ext(prec_possible_raster), resolution = res(prec_possible_raster), crs = crs(prec_possible_raster))
  
  
  for (i in 1:nlyr(prec_possible_raster)) {
    prec <- prec_possible_raster[[i]]
    temp <- heat_days_class_raster[[i]]
    
    s <- ifel(prec == 1 & temp == 1, 1, 
              ifel(prec ==2 & temp == 1 | prec == 3 & temp == 1 | prec == 1 & temp ==2 | prec == 3 & temp == 2, 2, 
                   ifel(prec == 2 & temp == 2, 3, 
                        ifel(prec >= 0 & temp == 3 | prec == 0 & temp >= 1, 4, NA))))
    
    add(TP_Final) <- s
  }
  
  
  
  ## the loop to do the final crop prediction classes on the basis of precipitation, heatdays and drought spells
  for (i in 1:nlyr(TP_Final)) {
    TP <- TP_Final[[i]]
    DS <- drought_spells_rast[[i]]
    
    l <- ifel(TP == 1 & DS == 1, 1, 
              ifel(TP == 1 & DS == 2 | TP == 2 & DS == 1, 2, 
                   ifel(TP == 2 & DS == 2 | TP == 3 & DS == 1 | TP == 3 & DS ==2 , 3, 
                        ifel(TP == 4 & DS >= 1 | TP >= 1 & DS ==3, 4, NA))))
    
    add(TPD_Final) <- l
  }
  
  return(TPD_Final)
  
}

# Calc mean values over a defined period 
mean_period_calc        <- function(time_start, time_end, data, type){
  
  #subset into 20 yr periodes 
  data_2021_2040 <- data[[ names(data) >= as.character(time_start) & names(data) <= as.character(time_end)]]
  #data_2021_2040 <- data[[ names(data) >= "2021-01-01" & names(data) <= "2040-12-31"]]
  
  #create a new Index containing only the day-mon information of the time attribute 
  index <- as.Date(names(data))%>%
    format(format = "%m-%d")

  # Uses the above created index as a new index for the whole stack 
  # Subsets the stack based on the index
  # Applys a function (mean) to the subseted Data 
  mean_ <- tapp(data_2021_2040,index, mean, type)
  

  
  return(mean_)
  
}




