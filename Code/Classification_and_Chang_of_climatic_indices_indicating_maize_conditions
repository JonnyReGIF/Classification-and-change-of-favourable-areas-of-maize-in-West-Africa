################################################################
#### Script to derive different effect on maize cultivation ####
################################################################


##  required packages
library(terra)
library(PCICt)
library(lubridate)


## set working directory
setwd("")

## path to the folder to store the data in
path <- ""

## first day of data stack (yyyy-mm-dd)
start_data <- "2021-01-01"

## last day of data stack (yyyy-mm-dd)
end_data <- "2100-12-31"



#################
#### Content ####
#################

# PART I:   Preprocessing Cordex Data 
# PART II:  Calculating Start of Rainy Season and thereby vegetation period 
# PART III: Identifying and classifying Temperature/Heat Days threshold values during vegetation period
# PART IV:  Calculating and classifying of Precipitation total during vegetation period
# PART v:   Calculating and classifying Drought Spells during vegetation period
# PART VI:  Final Classification to evaluate possible Maize Cultivation areas
# PART VII: Visualization - GIF



##############################################################################################################


###########################################
#### PART I: Preprocessing Cordex Data ####
###########################################

## NOTE: 
# we are using the following CORDEX Data: daily Precipitation, daily Mean Temperature, daily Max Temperature (from 2021 till 2100 in 5 y stacks, spatial resolution 22' x 22', rcp 45, Africa)
# additionally maize cultivation areas (here, by Monfreda et al. 2008)
# preprocessing means: cropping the Data to the extent of the Area of interest, resampling the data, mask the pixels where no maize is cultivated 



## load or access necessary data
files_Tmean <- list.files(paste0(getwd(), "/02_Daten/CordexData/Temp_Mean")) #lists mean Temperature nc-file names
files_P <- list.files(paste0(getwd(), "/02_Daten/CordexData/Precipitation")) #lists Precipitation nc-file names
files_Tmax <- list.files(paste0(getwd(), "/02_Daten/CordexData/Temp_Max")) #lists max Temperature nc-file names
UG <- vect("./02_Daten/Extent_FC/Extent_FC.shp") # shapefile -> area of interest
maize <- rast("./02_Daten/Maize_hektar_pro_pixel.tif") # raster image of reasoned areas of maize cultivation


## due to run time issues when single functions were applied to the whole raster stack (Data from 2021 til 2100) we applied a loop running through each 5-years stack individually

## loop to preprocess Mean Temperature Data
tmean_v <- c(paste0("r_Tmean_", 1:length(files_Tmean)))  # defines a vector to name the raster stacks

for (i in 1:length(files_Tmean)) {
  r <- rast(c(paste0(getwd(), "/02_Daten/CordexData/Temp_Mean/", files_Tmean[i]))) # loads first data set
  crs(r) <- crs(UG) # defines crs 
  c <- crop(r, ext(UG)) # crops the data to the extent of the area of interest
  t <- c - 273.15 # the temperature units are in Kelvin (K)  -> converting them into degree Celsius 
  m <- terra::resample(maize, t) # resamples pixel size of the "maize" data (actual cultivation areas)
  e <- terra::mask(t, m, maskvalues = 0, updatevalue = NA) # masks the data, so all pixels where no maize is cultivated get set to "NA"
  assign(tmean_v[i], e) # preprocessed dataset gets assigned to a unique name 
}



## loop to preprocess Max Temperature Data, same procedure as loop above
tmax_v <- c(paste0("r_Tmax_", 1:length(files_Tmax)))

for (i in 1:length(files_Tmax)) {
  r <- rast(c(paste0(getwd(), "/02_Daten/CordexData/Temp_Max/", files_Tmax[i])))
  crs(r) <- crs(UG)
  c <- crop(r, ext(UG))
  t <- c - 273.15
  m <- terra::resample(maize, t)
  e <- terra::mask(t, m, maskvalues = 0, updatevalue = NA)
  assign(tmax_v[i], e)
}


## loop to preprocess Precipitation Data
prec_v <- c(paste0("r_P_", 1:length(files_P)))

for (i in 1:length(files_P)) {
  r <- rast(c(paste0(getwd(), "/02_Daten/CordexData/Precipitation/", files_P[i])))
  crs(r) <- crs(UG)
  c <- crop(r, ext(UG))
  ## the unit of the data is kg m-2 s-1, we convert it to mm/day
  ## to convert from mass to volume we need density, assumption: that 1L of water = 1 kg
  ## 1L of water spread over 1m^2 is 1mm, so by that we got from kg m-2 s-1 to mm/s
  ## one day has 86400 seconds, we multiply the raster units with that number to get daily resolution  
  t <- c * 86400
  m <- terra::resample(maize, t) 
  e <- terra::mask(t, m, maskvalues = 0, updatevalue = NA)
  assign(prec_v[i], e)
}


## stacking preprocessed data to get all years from 2021- 2100 in one file each 
T_mean <- rast(mget(as.vector(tmean_v)))
T_max <- rast(mget(as.vector(tmax_v)))
prec <- rast(mget(as.vector(prec_v)))

names(T_mean) <- seq(as.PCICt(start_data, cal = "365_day"), as.PCICt(end_data, cal = "365_day"), by = "day")
names(T_max) <- seq(as.PCICt(start_data, cal = "365_day"), as.PCICt(end_data, cal = "365_day"), by = "day")
names(prec) <- seq(as.PCICt(start_data, cal = "365_day"), as.PCICt(end_data, cal = "365_day"), by = "day")


## saving Data as nc-file
# writeCDF(ras_Tmean,"./02_Daten/Temp_Mean_2021_2100.nc", overwrite = TRUE)
# writeCDF(ras_Tmax,"./02_Daten/Temp_Max_2021_2100.nc", overwrite = TRUE)
# writeCDF(ras_P,"./02_Daten/Precipitation_2021_2100.nc", overwrite = TRUE)


## saving data as raster (grd) file
writeRaster(T_mean, paste0(path,"/Temp_Mean_", substr(names(T_mean[[1]]), 1, 4), "_", substr(names(T_mean[[nlyr(T_mean)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)
writeRaster(T_max, paste0(path,"/Temp_Max_", substr(names(T_max[[1]]), 1, 4), "_", substr(names(T_max[[nlyr(T_max)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)
writeRaster(prec, paste0(path,"/Precipitation_", substr(names(prec[[1]]), 1, 4), "_", substr(names(prec[[nlyr(prec)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)

##############################################################################################################

## relevant for period calculations only ## 
## load required data
# prec <- rast("./02_Daten/Yearly_Data_2021_2100/Precipitation_2021_2100.grd")
# prec <- terra::subset(prec, as.character(seq(as.PCICt(start_period, cal = "365_day"), as.PCICt(end_period, cal = "365_day"), by = "day"))) 
# 
# 
# T_max <- rast("./02_Daten/Yearly_Data_2021_2100/Temp_Max_2021_2100.grd")
# T_max <- terra::subset(T_max, as.character(seq(as.PCICt(start_period, cal = "365_day"), as.PCICt(end_period, cal = "365_day"), by = "day"))) 
# 
# T_mean <- rast("./02_Daten/Yearly_Data_2021_2100/Temp_Mean_2021_2100.grd")
# T_mean <- terra::subset(T_mean, as.character(seq(as.PCICt(start_period, cal = "365_day"), as.PCICt(end_period, cal = "365_day"), by = "day")))
# 


#################################################################################
#### PART II: Identify Start of Rainy Season and thereby vegetation period ######
#################################################################################

## Note:
# Calculation according to Dunning et al. 2016


## in case not loaded, load necessary Precipitation data 
prec <- terra::rast("./02_Daten/Yearly_Data_2021_2100/Precipitation_2021_2100.grd")


## creating empty raster to store output of the following loops in it
prec_q_quer <- rast(extent = ext(prec), resolution = res(prec), crs = crs(prec))  # Q_quer = Mean precipitation of one year for each pixel
precipitation_anomaly <- rast(extent = ext(prec), resolution = res(prec), crs = crs(prec))  # daily precipitation anomaly data for one year
storage_cumulative <- rast(extent = ext(prec), resolution = res(prec), crs = crs(prec))  # cumulative sum of the precipitation anomaly for each year
table_start_end_day <- as.data.frame(prec, xy = TRUE)[, 1:2]  # data frame to store calculated start and end days of rainy season in


## create additional data sets/sequences etc.
# two sequences to indicate the layer who are representing the first/last day for each year
l <- seq(1, nlyr(prec), 365)
m <- seq(365, nlyr(prec), 365)


# sequence that indicates the potential time span where the onset of main annual rainy season could be (required to subset dataset)
# "60" represents the day of the year we are postulating to be the earliest the rainy season could start 
# "212" represents the day of the year we are postulating to be the latest the rainy season could start
l2 <- seq(60, nlyr(prec), 365) 
m2 <- seq(212, nlyr(prec), 365) 

# vector of numbers to name each year of time period
n <- c(substr(names(prec[[1]]), 1, 4):substr(names(prec[[nlyr(prec)]]), 1, 4))  


### loop to calculate Q_quer
# just in case: sets all run variables to zero 
i <- 0
y_start <- 0
j_start <- 0
y_end <- 0
j_end <- 0

## the loop to calculate Q_quer
for (i in 1:length(unique(year(ymd(c(names(prec))))))){
  
  # define start of the year
  y_start <- unique(year(ymd(c(names(prec)))))[i]
  j_start <- paste0(y_start,"-01-01")
  
  # define last day of year
  y_end <- unique(year(ymd(c(names(prec)))))[i]
  j_end <- paste0(y_end,"-12-31")
  
  # subset one year by start and end of year
  # sub creates a T (True == in time range) or F (not in time range) binary mask
  # the mask is uses to subset the actual data
  sub <- time(prec) >= as.POSIXct(j_start) & time(prec) <= as.POSIXct(j_end)
  subset <- prec[[sub]]
  
  
  # calc Q_quer = Mean daily precipitation of one year for each pixel
  result <- app(subset, fun = mean) # app() applies cell based calculations
  add(prec_q_quer) <- result # store results 
  names(prec_q_quer)[i] <- unique(year(ymd(c(names(prec)))))[i]
}


### loop to calculate daily precipitation anomaly for each day and pixel of the year
# just in case: sets all run variables to zero 
i <- 0
j <- 0
y_start <- 0
j_start <- 0
y_end <- 0
j_end <- 0


## loop to calculate the precipitation anomaly
for (i in 1:nlyr(prec_q_quer)) {
  # define start of year
  y_start <- unique(year(ymd(c(names(prec)))))[i]
  j_start <- paste0(y_start,"-01-01")
  #print(paste0(i, " ", j_start))
  
  # define end of year
  y_end <- unique(year(ymd(c(names(prec)))))[i]
  j_end <- paste0(y_end,"-12-31")
  #print(paste0(i, " ", j_end))
  
  # subset one year by start and end of year
  # sub creates a T (True == in time range) or F (not in time range) binary mask
  # the mask is uses to subset the actual Data
  sub <- names(prec) >= as.POSIXct(j_start) & names(prec) <= as.POSIXct(j_end)
  subset <- prec[[sub]]
  
  
  # calculates the precipitation anomaly -> the actual precipitation value of each day minus the mean precipitation value (Q_quer) for each pixel
  result <- subset - prec_q_quer[[i]] # app() applies cell based calculations
  
  add(precipitation_anomaly) <- result # store the results
  
}


### the loop that calculates the cumulative anomaly for each day of a year
# just in case: sets all run variables to zero 
j <- 0
i <- 0


## the loop to calculate the cumulative anomaly
for (i in 1:(nlyr(precipitation_anomaly)/365)) {
  cumulativ <- 0
  sub_anomaly <- 0
  s <- 1  
  e <- 365  
  
  l <- seq(s, nlyr(precipitation_anomaly), 365)
  m <- seq(e, nlyr(precipitation_anomaly), 365)
  
  sub_anomaly <- c(precipitation_anomaly[[l[i]:m[i]]]) # again subset for every year 
  
  cumulativ <- app(sub_anomaly, fun = cumsum) # app() applies cell based calculations
  
  add(storage_cumulative) <- cumulativ # store the results
  
}


### loop to identify the layer (=day) of each year where the pixel value is the the minimum (=start of the rainy season = start of vegeation period)
# just in case: sets all run variables to zero 
i <- 0
t <- 0

## the loop to find minimum value of cumulative precipitation anomaly (=onset of rainy season)
for (i in 1:(nlyr(storage_cumulative)/365)) {

  table_cumulative <- as.data.frame(storage_cumulative[[l2[i]:m2[i]]]) # subsetting the data year wise and converting it into a data frame
  min_index <- apply(table_cumulative, 1, which.min) # identifying for each pixel the column (=day of selected year) where the value is the minimum
  
  t <- cbind(start_day_ = (min_index + 59), # creating a new data frame with the start day of the rainy season = start of vegetation period for the selected day (we need to add 59 days since we cutted out the first 60 days of the year)
             end_day_ = (min_index+120+59)) # maize has a vegetation period of 120 d, so that marks the end of the vegetation period 
  colnames(t)[1] <- paste0("start_day_", n[i]) # renaming the columns (adding the selected year)
  colnames(t)[2] <- paste0("end_day_", n[i])  # renaming the columns (adding the selected year)
  table_start_end_day <- cbind(table_start_end_day, t) # adding the data frame we just created to the data frame containing x-/y-coordinates
}


## saving datatable 
write.table(table_start_end_day, paste0(path,"/Rainy_season_", substr(names(prec[[1]]), 1, 4), "_", substr(names(prec[[nlyr(prec)]]), 1, 4), ".txt"))

##############################################################################################################


###############################################################################################################
#### PART III: Identifying and classifying Temperature/Heat Days threshold values during vegetation period ####
###############################################################################################################

## loop to identify Heat days during the dynamic growing period for each year 
## furthermore the loop classifies the data, classes derived from literature, see txt file for reference list 
## Loop classifies in: 
# 1: T mean = 15 - 32�C (optimal growth)
# 2: T mean > 32�C (risk yield loss)
# 3: T max > 46�C (risk crop failure)
# 0: criteria have not been met


## in case not loaded, load necessary Precipitation data
T_mean <- terra::rast("./02_Daten/Yearly_Data_2021_2100/Temp_Mean_2021_2100.grd")
T_max <- terra::rast("./02_Daten/Yearly_Data_2021_2100/Temp_Max_2021_2100.grd")
table_start_end_day <- read.csv("./02_Daten/Yearly_Data_2021_2100/Rainy_season_2021_2100.txt", sep = " ")


## additional data transformation, conversion to data frame
table_Tmean <- as.data.frame(T_mean)
table_Tmax <- as.data.frame(T_max)


## creation of different data sets we are going to need
heat_days_growing_season <- as.data.frame(T_mean, xy = TRUE)[, 1:2]   # creating data frame with x and y column 
heat_days_possible <- as.data.frame(T_mean, xy = TRUE)[, 1:2]   # creating data frame with x and y column 
heat_days_class_raster <- rast(extent = ext(T_mean), resolution = res(T_mean), crs = crs(T_mean)) # empty raster to store loop output data
n <- c(substr(names(T_mean[[1]]), 1, 4):substr(names(T_mean[[nlyr(T_mean)]]), 1, 4))  # vector with years. used to name new data
ts <- seq(3,ncol(table_start_end_day), 2) # vector we need to specify the column for the start day of rainy season for each year
te <- seq(4,ncol(table_start_end_day), 2) # vector we need to specify the column for the end day of vegetation period for each year


# just in case: sets all run variables to zero 
j <- i <- s <- e <- l <- m <- u <- b <- t <- 0

## the loop to identify heat days during vegetation period and classify the temperatures
for (j in 1:(ncol(table_Tmean)/365)) {
  sub_Tmean <- data.frame()
  sub_Tmax <- data.frame()
  s <- 1  
  e <- 365  
  l <- seq(s, ncol(table_Tmean), 365)
  m <- seq(e, ncol(table_Tmean), 365)
  
  sub_mean <- table_Tmean[l[j]:m[j]]  # subsetting the mean Temperature data frame to the right year
  sub_max <- table_Tmax[l[j]:m[j]]    # subsetting the max Temperature data frame to the right year
  for (i in 1:nrow(sub_mean)) {
    u <- sub_mean[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]]   # this loop subsets the selected year data to the dynamic vegetation period for each pixel
    b <- sub_max[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]]    # this loop subsets the selected year data to the dynamic vegetation period for each pixel
    colnames(u) <- c(1:120)
    colnames(b) <- c(1:120)
    sub_Tmean <- rbind(sub_Tmean, u)
    sub_Tmax <- rbind(sub_Tmax, b)
  }
  
  ## classification of the results by ifelse queries 
  t <- ifelse(sub_Tmax >= 46, 3,    # risk crop failure 
              ifelse(sub_Tmean > 32, 2, # risk yield loss  
                     ifelse(sub_Tmean >= 15 & sub_Tmean <= 32, 1, 0)))# optimal growth, if no conditions are met - set to zero
  
  colnames(t) <- paste0("day_", c(1:121))
  ge <- cbind(as.data.frame(T_mean, xy = TRUE)[, 1:2], t) # add the classification results to data frame including coordinates
  
  ge_r <- rast(ge, type = "xyz", crs = "EPSG:4326")  # assign crs 
  
  
  p_2 <- app(ge_r, fun = max)  # function to identify the maximum value of the temperature classification for each growing period, the highest number 
                               # for a pixel within the annual vegetation period is how this pixel will be classified for this specific year 
  
  names(p_2) <- n[j] # assign the vector with years to name new data
  add(heat_days_class_raster) <- p_2 # store final results in the heat day raster 
}


## saving the Temperature classification
writeRaster(heat_days_class_raster, paste0(path,"/Temp_Classification_", substr(names(T_mean[[1]]), 1, 4), "_", substr(names(T_mean[[nlyr(T_mean)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)


##############################################################################################################


################################################################################################
#### PART IV: Calculation and classification of precipitation sums during vegetation period ####
################################################################################################

## loop to calculate the precipitation sum for the dynamic vegetation period for each year 
## furthermore the loop classifies the data, classes derived from literature, see txt file for reference list 
## Loop classifies in: 
# 1: 600 mm > prec > 1200mm (optimal growth)
# 2: 400 mm > prec > 600mm (slightly too dry, risk of yield reduction) 
# 3: 1200 mm > prec > 1800mm (slightly too wet, risk of yield reduction)
# 0: criteria have not been met, too dry or too wet, risk of crop failure

## in case not loaded, load necessary Precipitation data
prec <- terra::rast("./02_Daten/Yearly_Data_2021_2100/Precipitation_2021_2100.grd")
table_start_end_day <- read.csv("./02_Daten/Yearly_Data_2021_2100/Rainy_season_2021_2100.txt", sep = " ")


## additional data transformation
table_prec <- as.data.frame(prec)


## creation of different data sets we are going to need
prec_possible <- as.data.frame(prec, xy = TRUE)[, 1:2] # creating data frame with x and y column
n <- c(substr(names(T_mean[[1]]), 1, 4):substr(names(T_mean[[nlyr(T_mean)]]), 1, 4))  # vector with years. used to name new data
ts <- seq(3,ncol(table_start_end_day), 2) # vector we need to specify the column for the start day of vegetation period for each year
te <- seq(4,ncol(table_start_end_day), 2) # vector we need to specify the column for the end day of vegetation period for each year

# just in case: sets all run variables to zero 
j <- i <- s <- e <- l <- m <- t <- u <- 0


## the loop to calculate precipitation sums within vegetation period and classify the results
for (j in 1:(ncol(table_prec)/365)) {
  
  sub_rs <- data.frame()
  
  s <- 1  
  e <- 365  
  
  l <- seq(s, ncol(table_prec), 365)
  m <- seq(e, ncol(table_prec), 365)
  
  sub <- table_prec[l[j]:m[j]] # sub for each year
  
  for (i in 1:nrow(sub)) {
    u <- sub[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]] # further only consider vegetation period of each year 
    colnames(u) <- c(1:121)
    sub_rs <- rbind(sub_rs, u)
  }
  
  sum_rs <- as.data.frame(apply(sub_rs, 1, FUN = sum)) # total precipitation (sum of daily) over vegetation period of every year
  colnames(sum_rs)[1] <- paste0("mm_", n[j])

  # classify the results with ifelse queries
  t <- ifelse(sum_rs >= 400 & sum_rs <= 600, 2, # risk yield reduction
              ifelse(sum_rs > 600 & sum_rs <= 1200, 1, # optimal growth 
                     ifelse(sum_rs > 1200 & sum_rs <= 1800, 3, 0))) # risk yield reduction, if no criteria met = zero = risk crop failure
  
  prec_possible <- cbind(prec_possible, t) # store the results
  
}

## convert data frame into raster stack and assign crs  
prec_possible_raster <- rast(prec_possible, type = "xyz", crs = "EPSG:4326")

## save the raster stack
writeRaster(prec_possible_raster, paste0(path,"/Prec_Classification_", substr(names(T_mean[[1]]), 1, 4), "_", substr(names(T_mean[[nlyr(T_mean)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)

##############################################################################################################


#####################################################################################
#### PART V: Calculating and classifying Drought Spells during vegetation period ####
#####################################################################################

## NOTE: 
# Drought Spells (DS) Analysis identifies consecutive dry days (Dry day = prec < 0.85 (Barron et al. 2003)) during the vegetation period for each year. 
# classes derived from literature, see txt file for reference list 
# loop classifies in:
# 1: DS <5 d (optimum growth)
# 2: 5 d < DS < 13 d (risk yield reduction)
# 3: DS >13 d (risk crop failure)


## in case not loaded, load necessary Precipitation data
prec <- terra::rast("./02_Daten/Yearly_Data_2021_2100/Precipitation_2021_2100.grd")
table_start_end_day <- read.csv("./02_Daten/Yearly_Data_2021_2100/Rainy_season_2021_2100.txt", sep = " ")


## additional data transformation
table_prec <- as.data.frame(prec)


## creation of different data sets we are going to need
drought_spells <- as.data.frame(prec, xy = T)[, 1:2]  # creating data frame with x and y column
n <- c(substr(names(T_mean[[1]]), 1, 4):substr(names(T_mean[[nlyr(T_mean)]]), 1, 4)) # vector with years. used to name new data
ts <- seq(3,ncol(table_start_end_day), 2) # vector we need to specify the column for the start day of vegetation period for each year
te <- seq(4,ncol(table_start_end_day), 2) # vector we need to specify the column for the end day of vegetation period for each year

# just in case: sets all run variables to zero 
j <- i <- s <- e <- l <- m <- t <- u <- 0 


## the loop to calculate and classify the drought spells 
for (j in 1:(ncol(table_prec)/365)) {
  
  sub_rs <- data.frame()
  
  s <- 1  
  e <- 365  
  
  l <- seq(s, ncol(table_prec), 365)
  m <- seq(e, ncol(table_prec), 365)
  
  sub <- table_prec[l[j]:m[j]] # sub for each year
  
  for (i in 1:nrow(sub)) { 
    u <- sub[i,  table_start_end_day[i, ts[j]]:table_start_end_day[i, te[j]]] # subset to only consider vegetation period of each year 
    colnames(u) <- c(1:121)
    sub_rs <- rbind(sub_rs, u)
  }
  
  table_sub_rs <- as.data.frame(sub_rs)
  t <- ifelse(table_sub_rs < 0.85, 1, 0) # classify dry day as day when prec < 0.85
  
  fe <- apply(t, 1, FUN = function(x=t) {
    rle <- rle(x) # rle function computes the lengths of runs of equal values in a vector 
    max_p <- max(rle$lengths[rle$values!=0]) # identify maximum dry spell lengths (= rle runs) within vegetation period
    op <- ifelse(max_p > 13, 3, # classify results, risk of crop failure
                 ifelse(max_p < 13 & max_p > 5, 2, 1)) # # risk of yield reduction, otherwise optimum growth 
  })
  
  drought_spells <- cbind(drought_spells, fe) # store results 
}

names(drought_spells)[3:ncol(drought_spells)] <- n # assign year names to the classification 


## convert result data frame into raster stack
drought_spells_rast <- rast(drought_spells, type = "xyz", crs = "EPSG:4326")

## save raster stack 
writeRaster(drought_spells_rast, paste0(path,"/Drought_Spell_Classification_", substr(names(T_mean[[1]]), 1, 4), "_", substr(names(T_mean[[nlyr(T_mean)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)

##############################################################################################################


####################################################################################
#### PART VI: Final Classification to evaluate possible Maize Cultivation areas ####
####################################################################################

## NOTE: 
# The final Classification. We bring the three different Indicators together and finalize the Classes 
# following Classes are made:
# 1:	optimum growth 
# 2:	risk slight yield reduction
# 3:	risk severe yield reduction
# 4:	risk crop failure 


## in case not loaded, load necessary data
prec_possible_raster <- rast("./02_Daten/Prec_Classification_2021_2100.grd")
heat_days_class_raster <- rast("./02_Daten/Temp_Classification_2021_2100.grd")
drought_spells_rast <- rast("./02_Daten/Drought_Spell_Classification_2021_2100.grd")


## creation of different data sets we are going to need
TP_Final <- rast(extent = ext(prec_possible_raster), resolution = res(prec_possible_raster), crs = crs(prec_possible_raster))
TPD_Final <- rast(extent = ext(prec_possible_raster), resolution = res(prec_possible_raster), crs = crs(prec_possible_raster))


## first loop to create crop classification on the basis of precipitation classes and temperature classes
for (i in 1:nlyr(prec_possible_raster)) {
  prec <- prec_possible_raster[[i]]
  temp <- heat_days_class_raster[[i]]
  
  s <- ifel(prec == 1 & temp == 1, 1, #if prec and temp are optimal -> optimal
            ifel(prec ==2 & temp == 1 | prec == 3 & temp == 1 | prec == 1 & temp ==2 | prec == 3 & temp == 2, 2,  # if one indice has yield reduction, the other optimum: risk slight reduction
                 ifel(prec == 2 & temp == 2, 3,  # special case: if it is slightly too hot and slightly too dry -> risk severe yield reduction 
                      ifel(prec >= 0 & temp == 3 | prec == 0 & temp >= 1, 4, NA)))) # if at least one of the indices has risk crop failure -> risk crop failure 
  
  add(TP_Final) <- s # store results 
}


## second loop to do the final crop classification, now adding the drought spell classes
for (i in 1:nlyr(TP_Final)) {
  TP <- TP_Final[[i]]
  DS <- drought_spells_rast[[i]]
  
  l <- ifel(TP == 1 & DS == 1, 1, # if all both are optimal -> optimal
            ifel(TP == 1 & DS == 2 | TP == 2 & DS == 1, 2, # if one optimal, the other risk slight reduction -> risk slight reduction
                 ifel(TP == 2 & DS == 2 | TP == 3 & DS == 1 | TP == 3 & DS ==2 , 3, # if both have risk slight reduction(or one risk severe reduction) -> risk severe reduction
                      ifel(TP == 4 & DS >= 1 | TP >= 1 & DS ==3, 4, NA)))) # if at least one has risk crop failure -> crop failure 
  
  add(TPD_Final) <- l # store results
}


## save raster stack 
writeRaster(TPD_Final, paste0(path,"/TPD_Final_", substr(names(T_mean[[1]]), 1, 4), "_", substr(names(T_mean[[nlyr(T_mean)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)
writeRaster(TP_Final, paste0(path,"/TP_Final_", substr(names(T_mean[[1]]), 1, 4), "_", substr(names(T_mean[[nlyr(T_mean)]]), 1, 4), ".grd"), filetype = "RRASTER", overwrite = TRUE)

##############################################################################################################


